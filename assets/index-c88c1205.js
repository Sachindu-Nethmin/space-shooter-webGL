var W=Object.defineProperty;var X=(i,t,e)=>t in i?W(i,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):i[t]=e;var o=(i,t,e)=>(X(i,typeof t!="symbol"?t+"":t,e),e);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))n(r);new MutationObserver(r=>{for(const a of r)if(a.type==="childList")for(const h of a.addedNodes)h.tagName==="LINK"&&h.rel==="modulepreload"&&n(h)}).observe(document,{childList:!0,subtree:!0});function e(r){const a={};return r.integrity&&(a.integrity=r.integrity),r.referrerPolicy&&(a.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?a.credentials="include":r.crossOrigin==="anonymous"?a.credentials="omit":a.credentials="same-origin",a}function n(r){if(r.ep)return;r.ep=!0;const a=e(r);fetch(r.href,a)}})();var G=1e-6,L=typeof Float32Array<"u"?Float32Array:Array;Math.hypot||(Math.hypot=function(){for(var i=0,t=arguments.length;t--;)i+=arguments[t]*arguments[t];return Math.sqrt(i)});function I(){var i=new L(16);return L!=Float32Array&&(i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[11]=0,i[12]=0,i[13]=0,i[14]=0),i[0]=1,i[5]=1,i[10]=1,i[15]=1,i}function Y(i){return i[0]=1,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=1,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=1,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,i}function K(i,t,e){var n=t[0],r=t[1],a=t[2],h=t[3],l=t[4],s=t[5],d=t[6],u=t[7],p=t[8],w=t[9],c=t[10],m=t[11],y=t[12],R=t[13],b=t[14],S=t[15],g=e[0],f=e[1],x=e[2],v=e[3];return i[0]=g*n+f*l+x*p+v*y,i[1]=g*r+f*s+x*w+v*R,i[2]=g*a+f*d+x*c+v*b,i[3]=g*h+f*u+x*m+v*S,g=e[4],f=e[5],x=e[6],v=e[7],i[4]=g*n+f*l+x*p+v*y,i[5]=g*r+f*s+x*w+v*R,i[6]=g*a+f*d+x*c+v*b,i[7]=g*h+f*u+x*m+v*S,g=e[8],f=e[9],x=e[10],v=e[11],i[8]=g*n+f*l+x*p+v*y,i[9]=g*r+f*s+x*w+v*R,i[10]=g*a+f*d+x*c+v*b,i[11]=g*h+f*u+x*m+v*S,g=e[12],f=e[13],x=e[14],v=e[15],i[12]=g*n+f*l+x*p+v*y,i[13]=g*r+f*s+x*w+v*R,i[14]=g*a+f*d+x*c+v*b,i[15]=g*h+f*u+x*m+v*S,i}function $(i,t,e,n,r,a,h){var l=1/(t-e),s=1/(n-r),d=1/(a-h);return i[0]=-2*l,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=-2*s,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=2*d,i[11]=0,i[12]=(t+e)*l,i[13]=(r+n)*s,i[14]=(h+a)*d,i[15]=1,i}var Q=$;function J(i,t,e,n){var r,a,h,l,s,d,u,p,w,c,m=t[0],y=t[1],R=t[2],b=n[0],S=n[1],g=n[2],f=e[0],x=e[1],v=e[2];return Math.abs(m-f)<G&&Math.abs(y-x)<G&&Math.abs(R-v)<G?Y(i):(u=m-f,p=y-x,w=R-v,c=1/Math.hypot(u,p,w),u*=c,p*=c,w*=c,r=S*w-g*p,a=g*u-b*w,h=b*p-S*u,c=Math.hypot(r,a,h),c?(c=1/c,r*=c,a*=c,h*=c):(r=0,a=0,h=0),l=p*h-w*a,s=w*r-u*h,d=u*a-p*r,c=Math.hypot(l,s,d),c?(c=1/c,l*=c,s*=c,d*=c):(l=0,s=0,d=0),i[0]=r,i[1]=l,i[2]=u,i[3]=0,i[4]=a,i[5]=s,i[6]=p,i[7]=0,i[8]=h,i[9]=d,i[10]=w,i[11]=0,i[12]=-(r*m+a*y+h*R),i[13]=-(l*m+s*y+d*R),i[14]=-(u*m+p*y+w*R),i[15]=1,i)}function C(){var i=new L(2);return L!=Float32Array&&(i[0]=0,i[1]=0),i}function B(i,t){var e=new L(2);return e[0]=i,e[1]=t,e}function Z(i,t){return i[0]=t[0],i[1]=t[1],i}function tt(i,t){var e=t[0],n=t[1],r=e*e+n*n;return r>0&&(r=1/Math.sqrt(r)),i[0]=t[0]*r,i[1]=t[1]*r,i}function O(i,t,e,n){var r=t[0]-e[0],a=t[1]-e[1],h=Math.sin(n),l=Math.cos(n);return i[0]=r*l-a*h+e[0],i[1]=r*h+a*l+e[1],i}(function(){var i=C();return function(t,e,n,r,a,h){var l,s;for(e||(e=2),n||(n=0),r?s=Math.min(r*e+n,t.length):s=t.length,l=n;l<s;l+=e)i[0]=t[l],i[1]=t[l+1],a(i,i,h),t[l]=i[0],t[l+1]=i[1];return t}})();class et{constructor(t,e,n,r){this.topLeft=t,this.topRight=e,this.bottomRight=n,this.bottomLeft=r}}class P{constructor(t,e,n,r){this.x=t,this.y=e,this.width=n,this.height=r}copy(){return new P(this.x,this.y,this.width,this.height)}}class rt{constructor(t,e,n){this.texture=t,this.drawRect=e,this.sourceRect=n}}class E{constructor(t,e,n,r,a){this.texture=t,this.sampler=e,this.id=n,this.width=r,this.height=a}static async createTexture(t,e){const n=t.createTexture({size:{width:e.width,height:e.height},format:"rgba8unorm",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT}),r=await createImageBitmap(e);t.queue.copyExternalImageToTexture({source:r},{texture:n},{width:e.width,height:e.height});const a=t.createSampler({magFilter:"nearest",minFilter:"nearest"});return new E(n,a,e.src,e.width,e.height)}static async createTextureFromURL(t,e){const r=await new Promise((a,h)=>{const l=new Image;l.src=e,l.onload=()=>a(l),l.onerror=()=>{console.error(`Failed to load image ${e}`),h()}});return E.createTexture(t,r)}}class it{constructor(t,e,n,r){this.textureCoords=t,this.size=e,this.advance=n,this.offset=r}}class at{constructor(t,e){o(this,"chars",{});this.texture=t,this.lineHeight=e}getChar(t){return this.chars[t]}createChar(t,e,n,r,a){this.chars[t]=new it(e,n,r,a)}}class T{static async initialize(t){this.playerTexture=await E.createTextureFromURL(t,"assets/PNG/playerShip1_blue.png"),this.ufoRedTexture=await E.createTextureFromURL(t,"assets/PNG/ufoRed.png"),this.uvTexture=await E.createTextureFromURL(t,"assets/uv_test.png"),this.spriteSheet=await E.createTextureFromURL(t,"assets/Spritesheet/sheet.png"),this.explosionTexture=await E.createTextureFromURL(t,"assets/explosion.png"),this.backgroundTexture=await E.createTextureFromURL(t,"assets/Backgrounds/purple.png"),await this.loadSpriteSheet(),this.spriteFont=await this.loadSnowBSpriteFont(t,"assets/SpriteFont.xml","assets/SpriteFont.png")}static async loadSpriteSheet(){const e=await(await fetch("assets/SpriteSheet/sheet.xml")).text();new DOMParser().parseFromString(e,"text/xml").querySelectorAll("SubTexture").forEach(a=>{const h=a.getAttribute("name").replace(".png",""),l=parseInt(a.getAttribute("x")),s=parseInt(a.getAttribute("y")),d=parseInt(a.getAttribute("width")),u=parseInt(a.getAttribute("height")),p=new P(0,0,d,u),w=new P(l,s,d,u);this.sprites[h]=new rt(this.spriteSheet,p,w)})}static async loadSnowBSpriteFont(t,e,n){const r=await E.createTextureFromURL(t,n),h=await(await fetch(e)).text(),s=new DOMParser().parseFromString(h,"text/xml"),d=parseInt(s.querySelector("common").getAttribute("lineHeight")),u=new at(r,d);return s.querySelectorAll("char").forEach(p=>{const w=parseInt(p.getAttribute("id")),c=parseInt(p.getAttribute("x")),m=parseInt(p.getAttribute("y")),y=parseInt(p.getAttribute("width")),R=parseInt(p.getAttribute("height")),b=parseInt(p.getAttribute("xadvance")),S=parseInt(p.getAttribute("xoffset")),g=parseInt(p.getAttribute("yoffset")),f=c/r.width,x=m/r.height,v=(c+y)/r.width,z=(m+R)/r.height,k=new et(B(f,x),B(v,x),B(v,z),B(f,z));u.createChar(w,k,B(y,R),b,B(S,g))}),u}}o(T,"spriteFont"),o(T,"playerTexture"),o(T,"ufoRedTexture"),o(T,"uvTexture"),o(T,"spriteSheet"),o(T,"backgroundTexture"),o(T,"explosionTexture"),o(T,"sprites",{});class V{static createVertexBuffer(t,e){const n=t.createBuffer({size:e.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});return new Float32Array(n.getMappedRange()).set(e),n.unmap(),n}static createIndexBuffer(t,e){const n=t.createBuffer({size:e.byteLength,usage:GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});return new Uint16Array(n.getMappedRange()).set(e),n.unmap(),n}static createUniformBuffer(t,e){return t.createBuffer({size:e.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})}}class st{constructor(t,e){o(this,"projection");o(this,"view");o(this,"projectionViewMatrix");this.width=t,this.height=e,this.projectionViewMatrix=I()}update(){this.projection=Q(I(),0,this.width,this.height,0,-1,1),this.view=J(I(),[0,0,1],[0,0,0],[0,1,0]),K(this.projectionViewMatrix,this.projection,this.view)}}class nt{constructor(t=1,e=1,n=1){this.r=t,this.g=e,this.b=n}}const ot=`struct VertexOut {\r
    @builtin(position) position: vec4f,\r
    @location(0) texCoords: vec2f,\r
    @location(1) color: vec4f,\r
}\r
\r
@group(0) @binding(0)\r
var<uniform> projectionViewMatrix: mat4x4f;\r
\r
@vertex \r
fn vertexMain(\r
    @location(0) pos: vec2f,  // xy\r
    @location(1) texCoords: vec2f, // uv\r
    @location(2) color: vec3f,  // rgb\r
) -> VertexOut \r
{ \r
   \r
    var output : VertexOut; \r
\r
    output.position = projectionViewMatrix * vec4f(pos, 0.0, 1.0);\r
    output.texCoords = texCoords;\r
    output.color = vec4f(color, 1.0);\r
\r
    return output;\r
}\r
\r
@group(1) @binding(0)\r
var texSampler: sampler;\r
\r
@group(1) @binding(1)\r
var tex: texture_2d<f32>;\r
\r
\r
@fragment\r
fn fragmentMain(fragData: VertexOut ) -> @location(0) vec4f \r
{\r
    var textureColor = textureSample(tex, texSampler, fragData.texCoords);\r
    return fragData.color * textureColor;\r
}\r
`;class _{constructor(){o(this,"pipeline");o(this,"textureBindGroup");o(this,"projectionViewBindGroup")}static create(t,e,n){const r=new _;return r.initialize(t,e,n),r}initialize(t,e,n){const r=t.createShaderModule({code:ot}),a={arrayStride:7*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,offset:0,format:"float32x2"},{shaderLocation:1,offset:2*Float32Array.BYTES_PER_ELEMENT,format:"float32x2"},{shaderLocation:2,offset:4*Float32Array.BYTES_PER_ELEMENT,format:"float32x3"}],stepMode:"vertex"},h={module:r,entryPoint:"vertexMain",buffers:[a]},l={module:r,entryPoint:"fragmentMain",targets:[{format:navigator.gpu.getPreferredCanvasFormat(),blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"}}}]},s=t.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"uniform"}}]}),d=t.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,sampler:{}},{binding:1,visibility:GPUShaderStage.FRAGMENT,texture:{}}]}),u=t.createPipelineLayout({bindGroupLayouts:[s,d]});this.textureBindGroup=t.createBindGroup({label:e.id,layout:d,entries:[{binding:0,resource:e.sampler},{binding:1,resource:e.texture.createView()}]}),this.projectionViewBindGroup=t.createBindGroup({layout:s,entries:[{binding:0,resource:{buffer:n}}]}),this.pipeline=t.createRenderPipeline({vertex:h,fragment:l,primitive:{topology:"triangle-list"},layout:u})}}const F=1e3,ht=7,U=4*ht,M=6;class A{constructor(t){o(this,"vertexData",new Float32Array(F*U));o(this,"instanceCount",0);this.pipeline=t}}class ct{constructor(t,e,n){o(this,"defaultColor",new nt);o(this,"currentTexture",null);o(this,"indexBuffer");o(this,"projectionViewMatrixBuffer");o(this,"camera");o(this,"passEncoder");o(this,"v0",C());o(this,"v1",C());o(this,"v2",C());o(this,"v3",C());o(this,"rotationOrigin",C());o(this,"pipelinesPerTexture",{});o(this,"batchDrawCallPerTexture",{});o(this,"allocatedVertexBuffers",[]);this.device=t,this.width=e,this.height=n,this.camera=new st(this.width,this.height)}setupIndexBuffer(){const t=new Uint16Array(F*M);for(let e=0;e<F;e++)t[e*M+0]=e*4+0,t[e*M+1]=e*4+1,t[e*M+2]=e*4+2,t[e*M+3]=e*4+2,t[e*M+4]=e*4+3,t[e*M+5]=e*4+0;this.indexBuffer=V.createIndexBuffer(this.device,t)}initialize(){this.projectionViewMatrixBuffer=V.createUniformBuffer(this.device,new Float32Array(16)),this.setupIndexBuffer()}framePass(t){this.passEncoder=t,this.batchDrawCallPerTexture={},this.currentTexture=null,this.camera.update(),this.device.queue.writeBuffer(this.projectionViewMatrixBuffer,0,this.camera.projectionViewMatrix)}drawSprite(t,e){if(this.currentTexture!=t){this.currentTexture=t;let h=this.pipelinesPerTexture[t.id];h||(h=_.create(this.device,t,this.projectionViewMatrixBuffer),this.pipelinesPerTexture[t.id]=h),this.batchDrawCallPerTexture[t.id]||(this.batchDrawCallPerTexture[t.id]=[])}const n=this.batchDrawCallPerTexture[t.id];let r=n[n.length-1];r||(r=new A(this.pipelinesPerTexture[t.id]),this.batchDrawCallPerTexture[t.id].push(r));let a=r.instanceCount*U;if(r.vertexData[0+a]=e.x,r.vertexData[1+a]=e.y,r.vertexData[2+a]=0,r.vertexData[3+a]=0,r.vertexData[4+a]=1,r.vertexData[5+a]=1,r.vertexData[6+a]=1,r.vertexData[7+a]=e.x+e.width,r.vertexData[8+a]=e.y,r.vertexData[9+a]=1,r.vertexData[10+a]=0,r.vertexData[11+a]=1,r.vertexData[12+a]=1,r.vertexData[13+a]=1,r.vertexData[14+a]=e.x+e.width,r.vertexData[15+a]=e.y+e.height,r.vertexData[16+a]=1,r.vertexData[17+a]=1,r.vertexData[18+a]=1,r.vertexData[19+a]=1,r.vertexData[20+a]=1,r.vertexData[21+a]=e.x,r.vertexData[22+a]=e.y+e.height,r.vertexData[23+a]=0,r.vertexData[24+a]=1,r.vertexData[25+a]=1,r.vertexData[26+a]=1,r.vertexData[27+a]=1,r.instanceCount++,r.instanceCount>=F){const h=new A(this.pipelinesPerTexture[t.id]);this.batchDrawCallPerTexture[t.id].push(h)}}drawSpriteSource(t,e,n,r=this.defaultColor,a=0,h=null){if(this.currentTexture!=t){this.currentTexture=t;let m=this.pipelinesPerTexture[t.id];m||(m=_.create(this.device,t,this.projectionViewMatrixBuffer),this.pipelinesPerTexture[t.id]=m),this.batchDrawCallPerTexture[t.id]||(this.batchDrawCallPerTexture[t.id]=[])}const l=this.batchDrawCallPerTexture[t.id];let s=l[l.length-1];s||(s=new A(this.pipelinesPerTexture[t.id]),this.batchDrawCallPerTexture[t.id].push(s));let d=s.instanceCount*U,u=n.x/t.width,p=n.y/t.height,w=(n.x+n.width)/t.width,c=(n.y+n.height)/t.height;if(this.v0[0]=e.x,this.v0[1]=e.y,this.v1[0]=e.x+e.width,this.v1[1]=e.y,this.v2[0]=e.x+e.width,this.v2[1]=e.y+e.height,this.v3[0]=e.x,this.v3[1]=e.y+e.height,a!=0&&(h==null?Z(this.rotationOrigin,this.v0):(this.rotationOrigin[0]=this.v0[0]+h[0]*e.width,this.rotationOrigin[1]=this.v0[1]+h[1]*e.height),O(this.v0,this.v0,this.rotationOrigin,a),O(this.v1,this.v1,this.rotationOrigin,a),O(this.v2,this.v2,this.rotationOrigin,a),O(this.v3,this.v3,this.rotationOrigin,a)),s.vertexData[0+d]=this.v0[0],s.vertexData[1+d]=this.v0[1],s.vertexData[2+d]=u,s.vertexData[3+d]=p,s.vertexData[4+d]=r.r,s.vertexData[5+d]=r.g,s.vertexData[6+d]=r.b,s.vertexData[7+d]=this.v1[0],s.vertexData[8+d]=this.v1[1],s.vertexData[9+d]=w,s.vertexData[10+d]=p,s.vertexData[11+d]=r.r,s.vertexData[12+d]=r.g,s.vertexData[13+d]=r.b,s.vertexData[14+d]=this.v2[0],s.vertexData[15+d]=this.v2[1],s.vertexData[16+d]=w,s.vertexData[17+d]=c,s.vertexData[18+d]=r.r,s.vertexData[19+d]=r.g,s.vertexData[20+d]=r.b,s.vertexData[21+d]=this.v3[0],s.vertexData[22+d]=this.v3[1],s.vertexData[23+d]=u,s.vertexData[24+d]=c,s.vertexData[25+d]=r.r,s.vertexData[26+d]=r.g,s.vertexData[27+d]=r.b,s.instanceCount++,s.instanceCount>=F){const m=new A(this.pipelinesPerTexture[t.id]);this.batchDrawCallPerTexture[t.id].push(m)}}drawString(t,e,n,r=this.defaultColor,a=1){const h=t.texture;if(this.currentTexture!=h){this.currentTexture=h;let u=this.pipelinesPerTexture[h.id];u||(u=_.create(this.device,h,this.projectionViewMatrixBuffer),this.pipelinesPerTexture[h.id]=u),this.batchDrawCallPerTexture[h.id]||(this.batchDrawCallPerTexture[h.id]=[])}const l=this.batchDrawCallPerTexture[h.id];let s=l[l.length-1];s||(s=new A(this.pipelinesPerTexture[h.id]),this.batchDrawCallPerTexture[h.id].push(s));let d=0;for(let u=0;u<e.length;u++){const p=e[u].charCodeAt(0),w=t.getChar(p);let c=s.instanceCount*U;const m=n[0]+(d+w.offset[0])*a,y=n[1]+w.offset[1]*a,R=w.size[0]*a,b=w.size[1]*a;this.v0[0]=m,this.v0[1]=y,this.v1[0]=m+R,this.v1[1]=y,this.v2[0]=m+R,this.v2[1]=y+b,this.v3[0]=m,this.v3[1]=y+b;const S=w.textureCoords.topLeft,g=w.textureCoords.topRight,f=w.textureCoords.bottomRight,x=w.textureCoords.bottomLeft;s.vertexData[0+c]=this.v0[0],s.vertexData[1+c]=this.v0[1],s.vertexData[2+c]=S[0],s.vertexData[3+c]=S[1],s.vertexData[4+c]=r.r,s.vertexData[5+c]=r.g,s.vertexData[6+c]=r.b,s.vertexData[7+c]=this.v1[0],s.vertexData[8+c]=this.v1[1],s.vertexData[9+c]=g[0],s.vertexData[10+c]=g[1],s.vertexData[11+c]=r.r,s.vertexData[12+c]=r.g,s.vertexData[13+c]=r.b,s.vertexData[14+c]=this.v2[0],s.vertexData[15+c]=this.v2[1],s.vertexData[16+c]=f[0],s.vertexData[17+c]=f[1],s.vertexData[18+c]=r.r,s.vertexData[19+c]=r.g,s.vertexData[20+c]=r.b,s.vertexData[21+c]=this.v3[0],s.vertexData[22+c]=this.v3[1],s.vertexData[23+c]=x[0],s.vertexData[24+c]=x[1],s.vertexData[25+c]=r.r,s.vertexData[26+c]=r.g,s.vertexData[27+c]=r.b,s.instanceCount++,d+=w.advance,s.instanceCount>=F&&(s=new A(this.pipelinesPerTexture[h.id]),this.batchDrawCallPerTexture[h.id].push(s))}}frameEnd(){let t=[];for(const e in this.batchDrawCallPerTexture){const n=this.batchDrawCallPerTexture[e];for(const r of n){if(r.instanceCount==0)continue;let a=this.allocatedVertexBuffers.pop();a?this.device.queue.writeBuffer(a,0,r.vertexData):a=V.createVertexBuffer(this.device,r.vertexData),t.push(a);const h=r.pipeline;this.passEncoder.setPipeline(h.pipeline),this.passEncoder.setIndexBuffer(this.indexBuffer,"uint16"),this.passEncoder.setVertexBuffer(0,a),this.passEncoder.setBindGroup(0,h.projectionViewBindGroup),this.passEncoder.setBindGroup(1,h.textureBindGroup),this.passEncoder.drawIndexed(6*r.instanceCount)}}for(let e of t)this.allocatedVertexBuffers.push(e)}}class dt{constructor(){o(this,"keyDown",{});window.addEventListener("keydown",t=>this.keyDown[t.key]=!0),window.addEventListener("keyup",t=>this.keyDown[t.key]=!1)}isKeyDown(t){return this.keyDown[t]}isKeyUp(t){return!this.keyDown[t]}}class lt{constructor(){o(this,"lastTime",0);o(this,"canvas");o(this,"context");o(this,"device");o(this,"passEncoder");o(this,"spriteRenderer");o(this,"inputManager");o(this,"gameBounds",C());o(this,"onUpdate",()=>{});o(this,"onDraw",()=>{})}async initialize(){if(this.canvas=document.getElementById("canvas"),this.context=this.canvas.getContext("webgpu"),this.gameBounds[0]=this.canvas.width,this.gameBounds[1]=this.canvas.height,!this.context){console.error("WebGPU not supported"),alert("WebGPU not supported");return}const t=await navigator.gpu.requestAdapter();if(!t){console.error("No adapter found"),alert("No adapter found");return}this.device=await t.requestDevice(),await T.initialize(this.device),this.context.configure({device:this.device,format:navigator.gpu.getPreferredCanvasFormat()}),this.spriteRenderer=new ct(this.device,this.canvas.width,this.canvas.height),this.spriteRenderer.initialize(),this.inputManager=new dt}draw(){const t=performance.now(),e=t-this.lastTime;this.lastTime=t,this.onUpdate(e);const n=this.device.createCommandEncoder(),r={colorAttachments:[{clearValue:{r:.8,g:.8,b:.8,a:1},loadOp:"clear",storeOp:"store",view:this.context.getCurrentTexture().createView()}]};this.passEncoder=n.beginRenderPass(r),this.spriteRenderer.framePass(this.passEncoder),this.onDraw(),this.spriteRenderer.frameEnd(),this.passEncoder.end(),this.device.queue.submit([n.finish()]),window.requestAnimationFrame(()=>this.draw())}}const ut=.25;class pt{constructor(t,e){o(this,"drawRect");o(this,"drawRect2");o(this,"gameHeight");this.gameHeight=e,this.drawRect=new P(0,0,t,e),this.drawRect2=new P(0,-e,t,e)}update(t){if(this.drawRect.y+=ut*t,this.drawRect2.y=this.drawRect.y-this.gameHeight,this.drawRect.y>this.gameHeight){const e=this.drawRect;this.drawRect=this.drawRect2,this.drawRect2=e}}draw(t){t.drawSprite(T.backgroundTexture,this.drawRect),t.drawSprite(T.backgroundTexture,this.drawRect2)}}class N{constructor(){o(this,"radius",0);o(this,"x",0);o(this,"y",0)}update(t){let e=t.width/2;t.height<t.width&&(e=t.height/2),this.x=t.x+this.radius,this.y=t.y+this.radius,this.radius=e}intersects(t){const e=this.x-t.x,n=this.y-t.y,r=Math.sqrt(e*e+n*n),a=this.radius+t.radius;return r<a}}const wt=.75;class ft{constructor(){o(this,"drawRect");o(this,"sourceRect");o(this,"texture");o(this,"active",!0);o(this,"collider",new N);const t=T.sprites.laserBlue01;this.texture=t.texture,this.sourceRect=t.sourceRect.copy(),this.drawRect=t.drawRect.copy()}spawn(t){this.active=!0,this.drawRect.x=t.drawRect.x+t.drawRect.width/2-this.drawRect.width/2,this.drawRect.y=t.drawRect.y-this.drawRect.height}update(t){this.drawRect.y-=wt*t,this.collider.update(this.drawRect),this.drawRect.y+this.drawRect.height<0&&(this.active=!1)}draw(t){t.drawSpriteSource(this.texture,this.drawRect,this.sourceRect)}}const xt=250;class gt{constructor(t){o(this,"pool",[]);o(this,"timeToSpawn",0);this.player=t}create(){let t=this.pool.find(e=>!e.active);t||(t=new ft,this.pool.push(t)),t.spawn(this.player)}intersectsEnemy(t){for(const e of this.pool)if(e.active&&e.collider.intersects(t.collider))return e.active=!1,!0;return!1}update(t){this.timeToSpawn+=t,this.timeToSpawn>xt&&(this.timeToSpawn=0,this.create());for(const e of this.pool)e.active&&e.update(t)}draw(t){for(const e of this.pool)e.active&&e.draw(t)}}const j=["meteorBrown_big1","meteorBrown_big2","meteorBrown_big3","meteorBrown_big4","meteorBrown_med1","meteorBrown_med3","meteorGrey_big1","meteorGrey_big2","meteorGrey_big3","meteorGrey_big4","meteorGrey_med1","meteorGrey_med2"],q=.05,vt=.25;class mt{constructor(t,e){o(this,"active",!0);o(this,"drawRect");o(this,"texture");o(this,"sourceRect");o(this,"speed",0);o(this,"rotation",0);o(this,"rotationSpeed",0);o(this,"rotationOrigin",B(.5,.5));o(this,"collider",new N);this.gameWidth=t,this.gameHeight=e;const n=j[Math.floor(Math.random()*j.length)],r=T.sprites[n];this.texture=r.texture,this.sourceRect=r.sourceRect.copy(),this.drawRect=r.drawRect.copy(),this.drawRect.y=-this.drawRect.height,this.drawRect.x=Math.random()*(this.gameWidth-this.drawRect.width),this.speed=Math.random()*(vt-q)+q,this.rotationSpeed=(Math.random()-.5)*.005}update(t){this.drawRect.y+=this.speed*t,this.rotation+=this.rotationSpeed*t,this.drawRect.y>this.gameHeight&&(this.active=!1),this.collider.update(this.drawRect)}draw(t){t.drawSpriteSource(this.texture,this.drawRect,this.sourceRect,void 0,this.rotation,this.rotationOrigin)}}const yt=1e3;class Dt{constructor(t,e,n,r,a,h){o(this,"timeToSpawn",0);o(this,"pool",[]);this.player=t,this.explosionManager=e,this.bulletManager=n,this.gameWidth=r,this.gameHeight=a,this.highScore=h}spawnEnemy(){if(this.timeToSpawn>yt){this.timeToSpawn=0;let t=this.pool.find(e=>!e.active);t||(t=new mt(this.gameWidth,this.gameHeight),this.pool.push(t)),t.active=!0,t.drawRect.x=Math.random()*(this.gameWidth-t.drawRect.width),t.drawRect.y=-t.drawRect.height}}update(t){this.timeToSpawn+=t,this.spawnEnemy();for(const e of this.pool)e.active&&(e.update(t),e.collider.intersects(this.player.collider)&&(e.active=!1,this.explosionManager.create(e.drawRect)),this.bulletManager.intersectsEnemy(e)&&(e.active=!1,this.explosionManager.create(e.drawRect),this.highScore.currentScore+=10),e.drawRect.y>this.gameHeight&&(e.active=!1))}draw(t){for(const e of this.pool)e.active&&e.draw(t)}}const Rt=1e3/30;class Tt{constructor(){o(this,"playing",!1);o(this,"timeToNextFrame",0);o(this,"sourceRect");o(this,"drawRect");o(this,"curretCol",0);o(this,"currentRow",0);o(this,"cols",4);o(this,"rows",4);this.sourceRect=new P(0,0,32,32),this.drawRect=new P(0,0,32,32)}play(t){this.playing=!0,this.timeToNextFrame=0,this.curretCol=0,this.currentRow=0,this.drawRect=t.copy()}update(t){this.playing&&(this.timeToNextFrame+=t,this.timeToNextFrame>Rt&&(this.timeToNextFrame=0,this.curretCol++,this.curretCol>=this.cols&&(this.curretCol=0,this.currentRow++,this.currentRow>=this.rows&&(this.currentRow=0,this.playing=!1))))}draw(t){this.sourceRect.x=this.curretCol*this.sourceRect.width,this.sourceRect.y=this.currentRow*this.sourceRect.height,t.drawSpriteSource(T.explosionTexture,this.drawRect,this.sourceRect)}}class bt{constructor(){o(this,"pool",[])}create(t){let e=this.pool.find(n=>!n.playing);e||(e=new Tt,this.pool.push(e)),e.play(t)}update(t){for(const e of this.pool)e.playing&&e.update(t)}draw(t){for(const e of this.pool)e.playing&&e.draw(t)}}const H=.25;class St{constructor(t,e,n){o(this,"movementDirection",C());o(this,"drawRect");o(this,"sourceRect");o(this,"texture");o(this,"collider",new N);this.inputManager=t,this.gameWidth=e,this.gameHeight=n;const r=T.sprites.playerShip1_blue;this.texture=r.texture,this.sourceRect=r.sourceRect.copy(),this.drawRect=r.drawRect.copy()}clampToBounds(){this.drawRect.x<0?this.drawRect.x=0:this.drawRect.x+this.drawRect.width>this.gameWidth&&(this.drawRect.x=this.gameWidth-this.drawRect.width),this.drawRect.y<0?this.drawRect.y=0:this.drawRect.y+this.drawRect.height>this.gameHeight&&(this.drawRect.y=this.gameHeight-this.drawRect.height)}update(t){this.movementDirection[0]=0,this.movementDirection[1]=0,this.inputManager.isKeyDown("ArrowLeft")?this.movementDirection[0]=-1:this.inputManager.isKeyDown("ArrowRight")&&(this.movementDirection[0]=1),this.inputManager.isKeyDown("ArrowUp")?this.movementDirection[1]=-1:this.inputManager.isKeyDown("ArrowDown")&&(this.movementDirection[1]=1),tt(this.movementDirection,this.movementDirection),this.drawRect.x+=this.movementDirection[0]*H*t,this.drawRect.y+=this.movementDirection[1]*H*t,this.clampToBounds(),this.collider.update(this.drawRect)}draw(t){t.drawSpriteSource(this.texture,this.drawRect,this.sourceRect)}}class Et{constructor(){o(this,"currentScore",0);o(this,"position",B(10,10))}draw(t){t.drawString(T.spriteFont,`Score: ${this.currentScore}`,this.position,void 0,.5)}}const D=new lt;D.initialize().then(()=>{const i=new St(D.inputManager,D.gameBounds[0],D.gameBounds[1]),t=new pt(D.gameBounds[0],D.gameBounds[1]),e=new bt,n=new gt(i),r=new Et,a=new Dt(i,e,n,D.gameBounds[0],D.gameBounds[1],r);D.onUpdate=h=>{i.update(h),t.update(h),a.update(h),e.update(h),n.update(h)},D.onDraw=()=>{t.draw(D.spriteRenderer),i.draw(D.spriteRenderer),a.draw(D.spriteRenderer),n.draw(D.spriteRenderer),e.draw(D.spriteRenderer),r.draw(D.spriteRenderer)},D.draw()});
